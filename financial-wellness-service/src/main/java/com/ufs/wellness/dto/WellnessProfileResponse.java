package com.ufs.wellness.dto;

import com.ufs.wellness.model.FinancialGoal;
import com.ufs.wellness.model.Recommendation;

import com.fasterxml.jackson.annotation.JsonFormat; // Jackson Core 2.15+
import com.fasterxml.jackson.annotation.JsonProperty; // Jackson Core 2.15+
import com.fasterxml.jackson.annotation.JsonInclude; // Jackson Core 2.15+
import jakarta.validation.constraints.NotNull; // Jakarta Validation API 3.0+
import jakarta.validation.constraints.Min; // Jakarta Validation API 3.0+
import jakarta.validation.constraints.Max; // Jakarta Validation API 3.0+
import jakarta.validation.Valid; // Jakarta Validation API 3.0+

import java.time.LocalDateTime; // Java 21
import java.util.List; // Java 21
import java.util.ArrayList; // Java 21
import java.util.UUID; // Java 21
import java.util.Objects;
import java.util.Collections;
import java.util.stream.Collectors;
import java.math.BigDecimal;

/**
 * Data Transfer Object (DTO) for sending financial wellness profile data in API responses.
 * 
 * This class encapsulates the wellness profile information that is sent to clients as part of
 * the Personalized Financial Wellness capability within the Unified Financial Services Platform.
 * It serves as the primary data structure for holistic financial profiling, combining customer 
 * wellness scores, financial goals, and personalized recommendations into a cohesive response.
 * 
 * Business Context:
 * This DTO implements the F-007: Personalized Financial Recommendations feature requirement,
 * enabling the delivery of comprehensive financial wellness assessments to customers through
 * various client applications including web dashboards, mobile applications, and API integrations.
 * 
 * The wellness profile aggregates data from multiple sources:
 * - Customer financial behavior and transaction patterns
 * - Progress tracking on established financial goals
 * - AI-generated personalized recommendations
 * - Historical wellness trend analysis
 * 
 * Design Principles:
 * - Immutable response structure to prevent accidental modification
 * - Comprehensive validation to ensure data integrity
 * - JSON-optimized serialization for efficient API communication
 * - Null-safe operations to handle partial data scenarios
 * - Extensive documentation for API consumers and developers
 * 
 * Security and Compliance Considerations:
 * - Contains customer financial data requiring appropriate access controls
 * - Supports audit logging for regulatory compliance (SOC2, PCI DSS, GDPR)
 * - Implements data masking capabilities for sensitive information
 * - Provides versioning support for backward compatibility
 * 
 * Performance Optimizations:
 * - Lazy loading support for large goal and recommendation collections
 * - Efficient JSON serialization with selective field inclusion
 * - Optimized for high-frequency API responses in microservices architecture
 * - Caching-friendly structure with appropriate immutability patterns
 * 
 * @author Unified Financial Services Platform Development Team
 * @version 1.0
 * @since 2025-01-01
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class WellnessProfileResponse {

    /**
     * Unique identifier for the wellness profile.
     * 
     * This UUID serves as the primary key for the wellness profile and enables:
     * - Direct profile retrieval and caching
     * - Cross-system correlation and audit trails
     * - Distributed system scalability without key collisions
     * - Privacy-compliant data operations and deletion
     * 
     * The identifier is generated by the wellness profile service and remains
     * constant throughout the profile lifecycle for consistency and traceability.
     */
    @JsonProperty("id")
    @NotNull(message = "Wellness profile ID is required")
    private final UUID id;

    /**
     * Unique identifier for the customer associated with this wellness profile.
     * 
     * Links this wellness assessment to a specific customer in the platform,
     * enabling:
     * - Customer-specific data segregation and privacy compliance
     * - Cross-service customer correlation and journey tracking
     * - Personalization engine data association
     * - Customer service and support workflows
     * 
     * This identifier maintains the relationship between the wellness profile
     * and the broader customer ecosystem while supporting data governance
     * and regulatory compliance requirements.
     */
    @JsonProperty("customerId")
    @NotNull(message = "Customer ID is required")
    private final UUID customerId;

    /**
     * Numerical wellness score representing the customer's overall financial health.
     * 
     * The wellness score is calculated using a proprietary algorithm that considers:
     * - Savings rate and emergency fund adequacy
     * - Debt-to-income ratios and credit utilization
     * - Investment diversification and retirement readiness
     * - Financial goal progress and achievement history
     * - Spending patterns and budgeting effectiveness
     * 
     * Score Range and Interpretation:
     * - 0-30: Critical - Immediate financial intervention needed
     * - 31-50: Poor - Significant improvement opportunities
     * - 51-70: Fair - Moderate financial health with room for growth
     * - 71-85: Good - Solid financial foundation with optimization potential
     * - 86-100: Excellent - Strong financial wellness and planning
     * 
     * The score is recalculated periodically based on updated financial data
     * and serves as a key metric for progress tracking and recommendation generation.
     */
    @JsonProperty("wellnessScore")
    @NotNull(message = "Wellness score is required")
    @Min(value = 0, message = "Wellness score must be between 0 and 100")
    @Max(value = 100, message = "Wellness score must be between 0 and 100")
    private final Integer wellnessScore;

    /**
     * Collection of financial goals associated with this wellness profile.
     * 
     * This list represents the customer's established financial objectives and includes:
     * - Short-term goals (emergency funds, vacation savings, debt payoff)
     * - Medium-term goals (home down payment, education funding, major purchases)
     * - Long-term goals (retirement planning, estate building, legacy creation)
     * 
     * Goal Management Features:
     * - Progress tracking with completion percentages
     * - Priority-based ordering for user interface presentation
     * - Status filtering (active, completed, paused, archived)
     * - Category-based organization for improved user experience
     * 
     * The goals collection is immutable in the response to prevent accidental
     * modification and ensure data consistency across client applications.
     * Modifications must be performed through dedicated goal management endpoints.
     */
    @JsonProperty("goals")
    @Valid
    private final List<FinancialGoal> goals;

    /**
     * Collection of personalized financial recommendations for the customer.
     * 
     * This list contains AI-generated recommendations tailored to the customer's
     * financial profile, goals, and current market conditions. Recommendations include:
     * - Actionable advice for improving financial wellness scores
     * - Goal-specific strategies for faster achievement
     * - Risk mitigation suggestions based on portfolio analysis
     * - Opportunity identification for income optimization
     * - Behavioral insights and habit improvement suggestions
     * 
     * Recommendation Characteristics:
     * - Priority-ordered for maximum impact and relevance
     * - Category-based organization (savings, investment, debt, insurance)
     * - Status tracking (pending, viewed, accepted, implemented, dismissed)
     * - Expiration handling for time-sensitive opportunities
     * 
     * The recommendations are refreshed regularly based on changing customer
     * circumstances and market conditions to maintain relevance and effectiveness.
     */
    @JsonProperty("recommendations")
    @Valid
    private final List<Recommendation> recommendations;

    /**
     * Timestamp when the wellness profile was initially created.
     * 
     * Provides audit trail information and enables:
     * - Customer lifecycle analysis and journey tracking
     * - Data retention policy enforcement for compliance
     * - Historical trend analysis and performance measurement
     * - System debugging and troubleshooting support
     * 
     * The creation timestamp remains constant throughout the profile lifecycle
     * and serves as a baseline for measuring customer progress and engagement.
     */
    @JsonProperty("createdAt")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    @NotNull(message = "Created date is required")
    private final LocalDateTime createdAt;

    /**
     * Timestamp when the wellness profile was last updated.
     * 
     * Indicates the freshness of the profile data and enables:
     * - Cache invalidation and refresh strategies
     * - Real-time data synchronization across client applications
     * - Change tracking for audit and compliance purposes
     * - Performance optimization for data retrieval operations
     * 
     * This timestamp is updated whenever significant profile changes occur,
     * including wellness score recalculation, goal modifications, or
     * recommendation generation cycles.
     */
    @JsonProperty("updatedAt")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    @NotNull(message = "Updated date is required")
    private final LocalDateTime updatedAt;

    /**
     * Default constructor for WellnessProfileResponse.
     * 
     * Initializes the response object with default values suitable for new profiles:
     * - Empty collections for goals and recommendations
     * - Current timestamp for creation and update dates
     * - Default wellness score requiring calculation
     * 
     * This constructor is primarily used by:
     * - Jackson JSON deserialization during API operations
     * - Spring Framework dependency injection and bean creation
     * - Unit testing frameworks for mock object creation
     * - Builder pattern implementations for response construction
     * 
     * Note: The default constructor creates an object with null IDs, which
     * should be set through appropriate setter methods or builder patterns
     * before the response is considered valid for client consumption.
     */
    public WellnessProfileResponse() {
        this.id = null;
        this.customerId = null;
        this.wellnessScore = 0;
        this.goals = new ArrayList<>();
        this.recommendations = new ArrayList<>();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Comprehensive constructor for creating a complete WellnessProfileResponse.
     * 
     * This constructor enables creation of fully populated response objects with
     * all required fields and collections, ensuring data integrity and validation.
     * 
     * @param id The unique identifier for the wellness profile
     * @param customerId The unique identifier for the associated customer
     * @param wellnessScore The calculated financial wellness score (0-100)
     * @param goals The list of financial goals associated with the profile
     * @param recommendations The list of personalized recommendations
     * @param createdAt The timestamp when the profile was created
     * @param updatedAt The timestamp when the profile was last updated
     * 
     * @throws IllegalArgumentException if any required parameter is null or invalid
     */
    public WellnessProfileResponse(UUID id, UUID customerId, Integer wellnessScore, 
                                 List<FinancialGoal> goals, List<Recommendation> recommendations,
                                 LocalDateTime createdAt, LocalDateTime updatedAt) {
        // Validate required parameters
        if (id == null) {
            throw new IllegalArgumentException("Wellness profile ID cannot be null");
        }
        if (customerId == null) {
            throw new IllegalArgumentException("Customer ID cannot be null");
        }
        if (wellnessScore == null) {
            throw new IllegalArgumentException("Wellness score cannot be null");
        }
        if (wellnessScore < 0 || wellnessScore > 100) {
            throw new IllegalArgumentException("Wellness score must be between 0 and 100");
        }
        if (createdAt == null) {
            throw new IllegalArgumentException("Created date cannot be null");
        }
        if (updatedAt == null) {
            throw new IllegalArgumentException("Updated date cannot be null");
        }
        
        // Initialize immutable fields
        this.id = id;
        this.customerId = customerId;
        this.wellnessScore = wellnessScore;
        this.goals = goals != null ? new ArrayList<>(goals) : new ArrayList<>();
        this.recommendations = recommendations != null ? new ArrayList<>(recommendations) : new ArrayList<>();
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    /**
     * Convenience constructor for creating a WellnessProfileResponse with current timestamps.
     * 
     * Automatically sets creation and update timestamps to the current system time,
     * simplifying response object creation for new profiles.
     * 
     * @param id The unique identifier for the wellness profile
     * @param customerId The unique identifier for the associated customer
     * @param wellnessScore The calculated financial wellness score (0-100)
     * @param goals The list of financial goals associated with the profile
     * @param recommendations The list of personalized recommendations
     */
    public WellnessProfileResponse(UUID id, UUID customerId, Integer wellnessScore,
                                 List<FinancialGoal> goals, List<Recommendation> recommendations) {
        this(id, customerId, wellnessScore, goals, recommendations, 
             LocalDateTime.now(), LocalDateTime.now());
    }

    // Accessor methods with comprehensive documentation

    /**
     * Gets the unique identifier for this wellness profile.
     * 
     * @return The UUID identifier for the wellness profile
     */
    public UUID getId() {
        return id;
    }

    /**
     * Gets the unique identifier for the customer associated with this profile.
     * 
     * @return The UUID identifier for the customer
     */
    public UUID getCustomerId() {
        return customerId;
    }

    /**
     * Gets the calculated financial wellness score.
     * 
     * @return The wellness score as an Integer between 0 and 100
     */
    public Integer getWellnessScore() {
        return wellnessScore;
    }

    /**
     * Gets an immutable view of the financial goals associated with this profile.
     * 
     * The returned list is unmodifiable to prevent accidental modification of the
     * response object state. Goal modifications should be performed through
     * dedicated service endpoints.
     * 
     * @return An unmodifiable list of FinancialGoal objects
     */
    public List<FinancialGoal> getGoals() {
        return Collections.unmodifiableList(goals);
    }

    /**
     * Gets an immutable view of the recommendations associated with this profile.
     * 
     * The returned list is unmodifiable to prevent accidental modification of the
     * response object state. Recommendation status updates should be performed
     * through dedicated service endpoints.
     * 
     * @return An unmodifiable list of Recommendation objects
     */
    public List<Recommendation> getRecommendations() {
        return Collections.unmodifiableList(recommendations);
    }

    /**
     * Gets the timestamp when this wellness profile was created.
     * 
     * @return The creation timestamp as LocalDateTime
     */
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    /**
     * Gets the timestamp when this wellness profile was last updated.
     * 
     * @return The last update timestamp as LocalDateTime
     */
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    // Business logic methods for enhanced functionality

    /**
     * Gets the count of financial goals associated with this profile.
     * 
     * @return The total number of goals
     */
    public int getGoalCount() {
        return goals != null ? goals.size() : 0;
    }

    /**
     * Gets the count of recommendations associated with this profile.
     * 
     * @return The total number of recommendations
     */
    public int getRecommendationCount() {
        return recommendations != null ? recommendations.size() : 0;
    }

    /**
     * Gets the count of active financial goals.
     * 
     * Active goals are those with status "ACTIVE" and are currently being pursued
     * by the customer. This metric helps assess customer engagement and planning activity.
     * 
     * @return The number of active goals
     */
    public long getActiveGoalCount() {
        return goals != null ? goals.stream()
                .filter(goal -> "ACTIVE".equals(goal.getStatus()))
                .count() : 0;
    }

    /**
     * Gets the count of completed financial goals.
     * 
     * Completed goals indicate successful achievement of financial objectives
     * and contribute to overall customer success metrics and platform effectiveness.
     * 
     * @return The number of completed goals
     */
    public long getCompletedGoalCount() {
        return goals != null ? goals.stream()
                .filter(goal -> "COMPLETED".equals(goal.getStatus()))
                .count() : 0;
    }

    /**
     * Gets the count of pending recommendations.
     * 
     * Pending recommendations represent actionable advice that the customer
     * has not yet reviewed or responded to, indicating potential engagement opportunities.
     * 
     * @return The number of pending recommendations
     */
    public long getPendingRecommendationCount() {
        return recommendations != null ? recommendations.stream()
                .filter(rec -> "PENDING".equals(rec.getStatus()))
                .count() : 0;
    }

    /**
     * Gets the count of high-priority recommendations.
     * 
     * High-priority recommendations require immediate customer attention and
     * often indicate critical financial issues or time-sensitive opportunities.
     * 
     * @return The number of high-priority recommendations
     */
    public long getHighPriorityRecommendationCount() {
        return recommendations != null ? recommendations.stream()
                .filter(rec -> "HIGH".equals(rec.getPriority()))
                .count() : 0;
    }

    /**
     * Calculates the overall goal completion percentage across all goals.
     * 
     * This metric provides insight into the customer's progress toward their
     * financial objectives and can be used for motivation and progress tracking.
     * 
     * @return The average completion percentage as a double (0.0 to 100.0)
     */
    public double getOverallGoalCompletionPercentage() {
        if (goals == null || goals.isEmpty()) {
            return 0.0;
        }
        
        double totalCompletion = goals.stream()
                .mapToDouble(FinancialGoal::getCompletionPercentage)
                .sum();
        
        return totalCompletion / goals.size();
    }

    /**
     * Gets the total target amount across all financial goals.
     * 
     * This represents the customer's total financial aspirations and can be used
     * for planning and resource allocation guidance.
     * 
     * @return The total target amount as BigDecimal
     */
    public BigDecimal getTotalTargetAmount() {
        if (goals == null || goals.isEmpty()) {
            return BigDecimal.ZERO;
        }
        
        return goals.stream()
                .filter(goal -> goal.getTargetAmount() != null)
                .map(FinancialGoal::getTargetAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Gets the total current amount across all financial goals.
     * 
     * This represents the customer's current progress toward their financial
     * objectives in monetary terms.
     * 
     * @return The total current amount as BigDecimal
     */
    public BigDecimal getTotalCurrentAmount() {
        if (goals == null || goals.isEmpty()) {
            return BigDecimal.ZERO;
        }
        
        return goals.stream()
                .filter(goal -> goal.getCurrentAmount() != null)
                .map(FinancialGoal::getCurrentAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Gets a list of goals filtered by status.
     * 
     * @param status The status to filter by (e.g., "ACTIVE", "COMPLETED")
     * @return A list of goals with the specified status
     */
    public List<FinancialGoal> getGoalsByStatus(String status) {
        if (goals == null || status == null) {
            return new ArrayList<>();
        }
        
        return goals.stream()
                .filter(goal -> status.equals(goal.getStatus()))
                .collect(Collectors.toList());
    }

    /**
     * Gets a list of recommendations filtered by priority.
     * 
     * @param priority The priority level to filter by (e.g., "HIGH", "MEDIUM", "LOW")
     * @return A list of recommendations with the specified priority
     */
    public List<Recommendation> getRecommendationsByPriority(String priority) {
        if (recommendations == null || priority == null) {
            return new ArrayList<>();
        }
        
        return recommendations.stream()
                .filter(rec -> priority.equals(rec.getPriority()))
                .collect(Collectors.toList());
    }

    /**
     * Gets a list of recommendations filtered by category.
     * 
     * @param category The category to filter by (e.g., "SAVINGS", "INVESTMENT")
     * @return A list of recommendations in the specified category
     */
    public List<Recommendation> getRecommendationsByCategory(String category) {
        if (recommendations == null || category == null) {
            return new ArrayList<>();
        }
        
        return recommendations.stream()
                .filter(rec -> category.equals(rec.getCategory()))
                .collect(Collectors.toList());
    }

    /**
     * Checks if the wellness profile has any active goals.
     * 
     * @return true if there are active goals, false otherwise
     */
    public boolean hasActiveGoals() {
        return getActiveGoalCount() > 0;
    }

    /**
     * Checks if the wellness profile has any pending recommendations.
     * 
     * @return true if there are pending recommendations, false otherwise
     */
    public boolean hasPendingRecommendations() {
        return getPendingRecommendationCount() > 0;
    }

    /**
     * Checks if the wellness profile has any high-priority recommendations.
     * 
     * @return true if there are high-priority recommendations, false otherwise
     */
    public boolean hasHighPriorityRecommendations() {
        return getHighPriorityRecommendationCount() > 0;
    }

    /**
     * Determines the wellness score category based on the score value.
     * 
     * @return A string describing the wellness category
     */
    public String getWellnessCategory() {
        if (wellnessScore == null) {
            return "UNKNOWN";
        }
        
        if (wellnessScore <= 30) {
            return "CRITICAL";
        } else if (wellnessScore <= 50) {
            return "POOR";
        } else if (wellnessScore <= 70) {
            return "FAIR";
        } else if (wellnessScore <= 85) {
            return "GOOD";
        } else {
            return "EXCELLENT";
        }
    }

    /**
     * Checks if the profile data is considered fresh based on the update timestamp.
     * 
     * @param hours The number of hours to consider as fresh
     * @return true if the profile was updated within the specified hours
     */
    public boolean isDataFresh(int hours) {
        if (updatedAt == null) {
            return false;
        }
        
        LocalDateTime threshold = LocalDateTime.now().minusHours(hours);
        return updatedAt.isAfter(threshold);
    }

    // Standard Object methods for proper collection handling and debugging

    /**
     * Compares this WellnessProfileResponse with another object for equality.
     * 
     * Two wellness profile responses are considered equal if they have the same
     * ID and customer ID, as these uniquely identify the profile.
     * 
     * @param obj The object to compare with
     * @return true if objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        
        WellnessProfileResponse that = (WellnessProfileResponse) obj;
        return Objects.equals(id, that.id) &&
               Objects.equals(customerId, that.customerId) &&
               Objects.equals(wellnessScore, that.wellnessScore) &&
               Objects.equals(goals, that.goals) &&
               Objects.equals(recommendations, that.recommendations) &&
               Objects.equals(createdAt, that.createdAt) &&
               Objects.equals(updatedAt, that.updatedAt);
    }

    /**
     * Generates a hash code for this WellnessProfileResponse.
     * 
     * The hash code is based on the unique identifier and key business fields
     * to ensure proper behavior in collections and caching scenarios.
     * 
     * @return The hash code as an integer
     */
    @Override
    public int hashCode() {    
        return Objects.hash(id, customerId, wellnessScore, goals, 
                          recommendations, createdAt, updatedAt);
    }

    /**
     * Returns a string representation of this WellnessProfileResponse.
     * 
     * Includes key identifying information and summary statistics for debugging
     * and logging purposes. Sensitive financial details are summarized rather
     * than exposed in full detail.
     * 
     * @return A detailed string representation of the wellness profile response
     */
    @Override
    public String toString() {
        return "WellnessProfileResponse{" +
                "id=" + id +
                ", customerId=" + customerId +
                ", wellnessScore=" + wellnessScore +
                ", wellnessCategory='" + getWellnessCategory() + '\'' +
                ", goalCount=" + getGoalCount() +
                ", activeGoalCount=" + getActiveGoalCount() +
                ", completedGoalCount=" + getCompletedGoalCount() +
                ", recommendationCount=" + getRecommendationCount() +
                ", pendingRecommendationCount=" + getPendingRecommendationCount() +
                ", highPriorityRecommendationCount=" + getHighPriorityRecommendationCount() +
                ", overallGoalCompletionPercentage=" + String.format("%.2f", getOverallGoalCompletionPercentage()) + "%" +
                ", totalTargetAmount=" + getTotalTargetAmount() +
                ", totalCurrentAmount=" + getTotalCurrentAmount() +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                ", dataFresh24h=" + isDataFresh(24) +
                '}';
    }
}