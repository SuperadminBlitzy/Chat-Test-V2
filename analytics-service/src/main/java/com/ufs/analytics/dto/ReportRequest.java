package com.ufs.analytics.dto;

import java.time.LocalDate;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.Valid;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonFormat;
import java.io.Serializable;
import java.util.Objects;

/**
 * Data Transfer Object (DTO) for requesting the generation of reports in the analytics service.
 * 
 * This class encapsulates all the parameters needed to generate specific reports including
 * regulatory compliance reports (F-003), settlement reconciliation reports (F-012), and
 * other analytical reports requested through the Compliance Control Center (F-015).
 * 
 * The DTO supports various report types including:
 * - REGULATORY_COMPLIANCE: Automated compliance reports for regulatory authorities
 * - SETTLEMENT_RECONCILIATION: Settlement reconciliation engine reports
 * - RISK_ASSESSMENT: AI-powered risk assessment reports
 * - TRANSACTION_MONITORING: Real-time transaction monitoring reports
 * - AUDIT_TRAIL: Comprehensive audit trail reports
 * - CUSTOMER_ANALYTICS: Customer behavior and analytics reports
 * 
 * Supported output formats include:
 * - PDF: Portable Document Format for regulatory submissions
 * - CSV: Comma-separated values for data analysis
 * - XLSX: Excel format for business users
 * - JSON: JavaScript Object Notation for API consumers
 * - XML: Extensible Markup Language for system integrations
 * 
 * @author Analytics Service Team
 * @version 1.0
 * @since 2025-01-01
 */
public class ReportRequest implements Serializable {

    /**
     * Serial version UID for serialization compatibility.
     * Ensures consistent serialization across different versions of the class.
     */
    private static final long serialVersionUID = 1L;

    /**
     * The type of report to be generated.
     * 
     * This field specifies which type of report should be generated by the analytics service.
     * Valid values include:
     * - REGULATORY_COMPLIANCE: For automated regulatory compliance reporting (F-003)
     * - SETTLEMENT_RECONCILIATION: For settlement reconciliation engine reports (F-012)
     * - RISK_ASSESSMENT: For AI-powered risk assessment reports
     * - TRANSACTION_MONITORING: For real-time transaction monitoring reports
     * - AUDIT_TRAIL: For comprehensive audit trail reports
     * - CUSTOMER_ANALYTICS: For customer behavior and analytics reports
     * 
     * The report type determines the data sources, processing logic, and output format
     * that will be used to generate the final report.
     */
    @NotNull(message = "Report type is mandatory and cannot be null")
    @NotBlank(message = "Report type cannot be blank or empty")
    @Size(min = 3, max = 50, message = "Report type must be between 3 and 50 characters")
    @Pattern(
        regexp = "^(REGULATORY_COMPLIANCE|SETTLEMENT_RECONCILIATION|RISK_ASSESSMENT|TRANSACTION_MONITORING|AUDIT_TRAIL|CUSTOMER_ANALYTICS|FINANCIAL_PERFORMANCE|COMPLIANCE_DASHBOARD)$",
        message = "Invalid report type. Must be one of: REGULATORY_COMPLIANCE, SETTLEMENT_RECONCILIATION, RISK_ASSESSMENT, TRANSACTION_MONITORING, AUDIT_TRAIL, CUSTOMER_ANALYTICS, FINANCIAL_PERFORMANCE, COMPLIANCE_DASHBOARD"
    )
    @JsonProperty("reportType")
    private String reportType;

    /**
     * The start date for the report's data range.
     * 
     * This field defines the beginning of the time period for which data should be included
     * in the report. The start date is inclusive, meaning data from this date will be included
     * in the report generation.
     * 
     * For regulatory compliance reports, this typically aligns with regulatory reporting periods.
     * For settlement reconciliation reports, this represents the beginning of the settlement period.
     * 
     * The date must be in the past or present to ensure data availability.
     */
    @NotNull(message = "Start date is mandatory for report generation")
    @PastOrPresent(message = "Start date cannot be in the future")
    @JsonProperty("startDate")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    private LocalDate startDate;

    /**
     * The end date for the report's data range.
     * 
     * This field defines the end of the time period for which data should be included
     * in the report. The end date is inclusive, meaning data from this date will be included
     * in the report generation.
     * 
     * The end date must be on or after the start date to ensure a valid date range.
     * For ongoing monitoring reports, this can be set to the current date.
     */
    @NotNull(message = "End date is mandatory for report generation")
    @PastOrPresent(message = "End date cannot be in the future")
    @JsonProperty("endDate")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    private LocalDate endDate;

    /**
     * The desired output format for the generated report.
     * 
     * This field specifies the format in which the report should be generated and delivered.
     * Supported formats include:
     * - PDF: Portable Document Format, ideal for regulatory submissions and formal reports
     * - CSV: Comma-separated values, suitable for data analysis and Excel import
     * - XLSX: Microsoft Excel format, for business users and advanced data manipulation
     * - JSON: JavaScript Object Notation, for API consumers and system integrations
     * - XML: Extensible Markup Language, for regulatory systems and B2B integrations
     * 
     * The format selection affects the report structure, styling, and delivery mechanism.
     */
    @NotNull(message = "Report format is mandatory")
    @NotBlank(message = "Report format cannot be blank or empty")
    @Pattern(
        regexp = "^(PDF|CSV|XLSX|JSON|XML)$",
        message = "Invalid report format. Must be one of: PDF, CSV, XLSX, JSON, XML"
    )
    @JsonProperty("format")
    private String format;

    /**
     * Default constructor for ReportRequest.
     * 
     * Creates a new instance of ReportRequest with all fields set to their default values.
     * This constructor is required for JSON deserialization and framework compatibility.
     * 
     * After using this constructor, all required fields must be set before the object
     * can be validated and used for report generation.
     */
    public ReportRequest() {
        // Default constructor - all fields will be initialized to their default values
        // This constructor is essential for JSON deserialization and Spring framework compatibility
    }

    /**
     * Parameterized constructor for ReportRequest.
     * 
     * Creates a new instance of ReportRequest with all required fields initialized.
     * This constructor provides a convenient way to create a fully populated request object.
     * 
     * @param reportType The type of report to generate (must not be null or blank)
     * @param startDate The start date for the report data range (must not be null)
     * @param endDate The end date for the report data range (must not be null)
     * @param format The desired output format for the report (must not be null or blank)
     * 
     * @throws IllegalArgumentException if any parameter is null or invalid
     */
    public ReportRequest(String reportType, LocalDate startDate, LocalDate endDate, String format) {
        this.reportType = reportType;
        this.startDate = startDate;
        this.endDate = endDate;
        this.format = format;
    }

    /**
     * Gets the type of the report to be generated.
     * 
     * @return The report type as a String, specifying which type of report should be generated.
     *         Returns null if the report type has not been set.
     */
    public String getReportType() {
        return reportType;
    }

    /**
     * Sets the type of the report to be generated.
     * 
     * This method allows setting the report type that determines the data sources,
     * processing logic, and output structure for the report generation.
     * 
     * @param reportType The report type to set. Must be one of the supported report types
     *                   (REGULATORY_COMPLIANCE, SETTLEMENT_RECONCILIATION, RISK_ASSESSMENT,
     *                   TRANSACTION_MONITORING, AUDIT_TRAIL, CUSTOMER_ANALYTICS, etc.)
     */
    public void setReportType(String reportType) {
        this.reportType = reportType;
    }

    /**
     * Gets the start date for the report's data range.
     * 
     * @return The start date as a LocalDate object, representing the beginning of the
     *         time period for which data should be included in the report.
     *         Returns null if the start date has not been set.
     */
    public LocalDate getStartDate() {
        return startDate;
    }

    /**
     * Sets the start date for the report's data range.
     * 
     * This method allows setting the beginning of the time period for which data
     * should be included in the report generation. The start date is inclusive.
     * 
     * @param startDate The start date to set. Must be in the past or present to ensure
     *                  data availability for report generation.
     */
    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    /**
     * Gets the end date for the report's data range.
     * 
     * @return The end date as a LocalDate object, representing the end of the
     *         time period for which data should be included in the report.
     *         Returns null if the end date has not been set.
     */
    public LocalDate getEndDate() {
        return endDate;
    }

    /**
     * Sets the end date for the report's data range.
     * 
     * This method allows setting the end of the time period for which data
     * should be included in the report generation. The end date is inclusive.
     * 
     * @param endDate The end date to set. Must be on or after the start date
     *                and cannot be in the future.
     */
    public void setEndDate(LocalDate endDate) {
        this.endDate = endDate;
    }

    /**
     * Gets the desired format for the report output.
     * 
     * @return The report format as a String, specifying how the report should be
     *         formatted and delivered (PDF, CSV, XLSX, JSON, or XML).
     *         Returns null if the format has not been set.
     */
    public String getFormat() {
        return format;
    }

    /**
     * Sets the desired format for the report output.
     * 
     * This method allows setting the output format that determines how the report
     * will be structured, styled, and delivered to the requesting system or user.
     * 
     * @param format The report format to set. Must be one of the supported formats
     *               (PDF, CSV, XLSX, JSON, XML).
     */
    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * Validates the date range to ensure the end date is not before the start date.
     * 
     * This method performs business logic validation to ensure that the specified
     * date range is valid for report generation. It checks that the end date is
     * on or after the start date.
     * 
     * @return true if the date range is valid (end date >= start date), false otherwise
     */
    public boolean isValidDateRange() {
        if (startDate == null || endDate == null) {
            return false;
        }
        return !endDate.isBefore(startDate);
    }

    /**
     * Calculates the number of days in the report date range.
     * 
     * This utility method calculates the total number of days covered by the report
     * request, which can be useful for determining processing time, data volume,
     * and report complexity.
     * 
     * @return The number of days in the date range, or 0 if dates are not set or invalid
     */
    public long getDateRangeDays() {
        if (startDate == null || endDate == null || !isValidDateRange()) {
            return 0;
        }
        return startDate.until(endDate).getDays() + 1; // +1 to include both start and end dates
    }

    /**
     * Checks if this is a regulatory compliance report request.
     * 
     * This convenience method determines if the current request is for generating
     * a regulatory compliance report, which has specific processing requirements
     * and validation rules.
     * 
     * @return true if this is a regulatory compliance report request, false otherwise
     */
    public boolean isRegulatoryComplianceReport() {
        return "REGULATORY_COMPLIANCE".equals(reportType);
    }

    /**
     * Checks if this is a settlement reconciliation report request.
     * 
     * This convenience method determines if the current request is for generating
     * a settlement reconciliation report, which requires specific data sources
     * and processing logic.
     * 
     * @return true if this is a settlement reconciliation report request, false otherwise
     */
    public boolean isSettlementReconciliationReport() {
        return "SETTLEMENT_RECONCILIATION".equals(reportType);
    }

    /**
     * Returns a string representation of the ReportRequest object.
     * 
     * This method provides a human-readable representation of the report request,
     * including all the key fields and their current values. This is useful for
     * logging, debugging, and audit trail purposes.
     * 
     * @return A string representation of the ReportRequest object
     */
    @Override
    public String toString() {
        return "ReportRequest{" +
                "reportType='" + reportType + '\'' +
                ", startDate=" + startDate +
                ", endDate=" + endDate +
                ", format='" + format + '\'' +
                ", dateRangeDays=" + getDateRangeDays() +
                ", isValidDateRange=" + isValidDateRange() +
                '}';
    }

    /**
     * Indicates whether some other object is "equal to" this one.
     * 
     * This method implements the equals contract for ReportRequest objects,
     * comparing all significant fields to determine equality. Two ReportRequest
     * objects are considered equal if all their fields are equal.
     * 
     * @param obj The reference object with which to compare
     * @return true if this object is the same as the obj argument; false otherwise
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        ReportRequest that = (ReportRequest) obj;
        return Objects.equals(reportType, that.reportType) &&
               Objects.equals(startDate, that.startDate) &&
               Objects.equals(endDate, that.endDate) &&
               Objects.equals(format, that.format);
    }

    /**
     * Returns a hash code value for the object.
     * 
     * This method implements the hashCode contract for ReportRequest objects,
     * generating a hash code based on all significant fields. This ensures that
     * equal objects have equal hash codes.
     * 
     * @return A hash code value for this object
     */
    @Override
    public int hashCode() {
        return Objects.hash(reportType, startDate, endDate, format);
    }
}