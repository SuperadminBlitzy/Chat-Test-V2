package com.ufs.transaction.dto;

import com.ufs.transaction.model.TransactionStatus;
import java.math.BigDecimal; // Java 21 - For precise financial calculations of the transaction amount
import java.time.LocalDateTime; // Java 21 - To represent the timestamp of the transaction
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.v3.oas.annotations.media.Schema;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.DecimalMin;
import javax.validation.constraints.Size;
import javax.validation.constraints.Pattern;
import java.io.Serializable;

/**
 * Data Transfer Object for sending transaction responses to clients.
 * 
 * This DTO encapsulates the complete details of a financial transaction response,
 * providing a standardized format for communicating transaction outcomes to client
 * applications. It contains comprehensive information about the transaction including
 * identification details, financial amounts, status information, and audit timestamps.
 * 
 * The DTO is designed to support the Transaction Processing workflow as defined in
 * Technical Specifications section 4.1.2 Integration Workflows/API Interaction Sequence,
 * serving as the primary response structure sent back to clients after transaction
 * processing requests.
 * 
 * Key Features:
 * - Comprehensive transaction information including financial details
 * - Immutable transaction identifiers for audit and tracking purposes
 * - Real-time status information reflecting current transaction state
 * - Standardized currency and amount representation using BigDecimal for precision
 * - Timestamp information for transaction lifecycle tracking
 * - Reference number for external system correlation and reconciliation
 * 
 * Usage Context:
 * This DTO is primarily utilized in the controller layer to construct API responses
 * for transaction-related endpoints. It ensures consistent data structure across
 * all transaction response scenarios including successful completions, failures,
 * and pending transactions.
 * 
 * Compliance Notes:
 * - Supports regulatory reporting requirements through comprehensive audit fields
 * - Maintains data consistency with core banking system representations
 * - Enables real-time transaction monitoring and risk assessment integration
 * - Facilitates blockchain settlement network integration through reference tracking
 * 
 * @author Unified Financial Services Platform
 * @version 1.0
 * @since 1.0
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
@Schema(
    name = "TransactionResponse",
    description = "Response object containing complete transaction details and status information"
)
public class TransactionResponse implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    /**
     * Unique identifier for the transaction within the Unified Financial Services Platform.
     * 
     * This identifier is generated by the transaction processing engine and serves as
     * the primary key for transaction tracking, audit trails, and system-wide correlation.
     * The format follows UUID v4 standard to ensure global uniqueness across all
     * distributed system components.
     * 
     * Usage:
     * - Primary key for transaction lookup and retrieval operations
     * - Correlation identifier for distributed tracing and monitoring
     * - Reference for customer service inquiries and dispute resolution
     * - Audit trail tracking across multiple system components
     */
    @NotBlank(message = "Transaction ID cannot be blank")
    @Size(min = 36, max = 36, message = "Transaction ID must be a valid UUID format")
    @Pattern(regexp = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", 
             message = "Transaction ID must be a valid UUID format")
    @Schema(
        description = "Unique transaction identifier in UUID format",
        example = "123e4567-e89b-12d3-a456-426614174000",
        required = true
    )
    @JsonProperty("transactionId")
    private String transactionId;
    
    /**
     * Account identifier associated with the transaction.
     * 
     * This represents the primary account involved in the transaction, typically
     * the source account for debits or destination account for credits. The account
     * ID follows the platform's standard account numbering scheme and enables
     * integration with core banking systems and customer account management.
     * 
     * Security Note:
     * Account IDs may be masked or tokenized in certain response contexts to
     * protect customer privacy and comply with data protection regulations.
     */
    @NotBlank(message = "Account ID cannot be blank")
    @Size(min = 8, max = 32, message = "Account ID must be between 8 and 32 characters")
    @Schema(
        description = "Account identifier involved in the transaction",
        example = "ACC123456789",
        required = true
    )
    @JsonProperty("accountId")
    private String accountId;
    
    /**
     * Transaction amount with high precision decimal representation.
     * 
     * Uses BigDecimal to ensure precise financial calculations without floating-point
     * arithmetic errors. The amount represents the monetary value involved in the
     * transaction, expressed in the specified currency. Positive values typically
     * represent credits, while negative values represent debits, though interpretation
     * may vary based on transaction type and business logic.
     * 
     * Precision Requirements:
     * - Scale: Up to 4 decimal places for fractional currency units
     * - Range: Supports amounts from micro-transactions to large institutional transfers
     * - Validation: Must be greater than zero for most transaction types
     */
    @NotNull(message = "Transaction amount cannot be null")
    @DecimalMin(value = "0.0001", inclusive = true, message = "Transaction amount must be greater than 0")
    @Schema(
        description = "Transaction amount with high precision decimal representation",
        example = "1250.75",
        required = true
    )
    @JsonProperty("amount")
    @JsonFormat(shape = JsonFormat.Shape.STRING)
    private BigDecimal amount;
    
    /**
     * ISO 4217 three-letter currency code for the transaction amount.
     * 
     * Specifies the currency denomination of the transaction amount, enabling
     * multi-currency support and proper financial reporting. The platform supports
     * major international currencies and digital currencies as defined in the
     * system configuration.
     * 
     * Supported Currencies:
     * - Major fiat currencies (USD, EUR, GBP, JPY, etc.)
     * - Regional currencies based on operational jurisdiction
     * - Digital currencies and stablecoins (where regulatory compliance permits)
     */
    @NotBlank(message = "Currency code cannot be blank")
    @Size(min = 3, max = 3, message = "Currency code must be exactly 3 characters")
    @Pattern(regexp = "^[A-Z]{3}$", message = "Currency code must be a valid ISO 4217 format")
    @Schema(
        description = "ISO 4217 three-letter currency code",
        example = "USD",
        required = true
    )
    @JsonProperty("currency")
    private String currency;
    
    /**
     * Type classification of the transaction for business logic and reporting purposes.
     * 
     * Categorizes the transaction according to business function and processing
     * requirements. This classification drives routing decisions in the transaction
     * processing workflow and determines applicable business rules, compliance
     * checks, and settlement procedures.
     * 
     * Common Transaction Types:
     * - DEPOSIT: Funds addition to account
     * - WITHDRAWAL: Funds removal from account
     * - TRANSFER: Inter-account or inter-customer fund movement
     * - PAYMENT: Bill payment or merchant transaction
     * - REFUND: Reversal of previous transaction
     * - FEE: Service charge or penalty assessment
     */
    @NotBlank(message = "Transaction type cannot be blank")
    @Size(min = 2, max = 20, message = "Transaction type must be between 2 and 20 characters")
    @Schema(
        description = "Transaction type classification",
        example = "TRANSFER",
        required = true,
        allowableValues = {"DEPOSIT", "WITHDRAWAL", "TRANSFER", "PAYMENT", "REFUND", "FEE"}
    )
    @JsonProperty("transactionType")
    private String transactionType;
    
    /**
     * Human-readable description of the transaction purpose or details.
     * 
     * Provides additional context about the transaction that may be displayed
     * to customers in statements, transaction histories, and notifications.
     * The description should be clear, concise, and informative while avoiding
     * sensitive information that could compromise security or privacy.
     * 
     * Content Guidelines:
     * - Maximum length to ensure compatibility with legacy systems
     * - Avoid special characters that may cause encoding issues
     * - Include relevant merchant or counterparty information when appropriate
     * - Maintain consistency with customer-facing transaction naming conventions
     */
    @Size(max = 255, message = "Transaction description cannot exceed 255 characters")
    @Schema(
        description = "Human-readable transaction description",
        example = "Transfer to John Doe - Rent payment",
        required = false
    )
    @JsonProperty("description")
    private String description;
    
    /**
     * Timestamp when the transaction was initially created or processed.
     * 
     * Records the precise moment when the transaction entered the system or
     * when processing was completed, depending on the transaction lifecycle stage.
     * This timestamp is crucial for audit trails, regulatory reporting, and
     * customer transaction history presentation.
     * 
     * Timezone Handling:
     * - All timestamps are stored and transmitted in UTC
     * - Client applications are responsible for timezone conversion for display
     * - Ensures consistency across multi-region deployments
     * 
     * Precision:
     * - Supports nanosecond precision for high-frequency trading scenarios
     * - Enables precise ordering of concurrent transactions
     * - Facilitates accurate performance metrics and SLA monitoring
     */
    @NotNull(message = "Transaction date cannot be null")
    @Schema(
        description = "Transaction creation or processing timestamp in ISO 8601 format",
        example = "2024-01-15T10:30:45.123456789",
        required = true
    )
    @JsonProperty("transactionDate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS")
    private LocalDateTime transactionDate;
    
    /**
     * Current status of the transaction in the processing lifecycle.
     * 
     * Represents the current state of the transaction within the transaction
     * processing workflow. The status provides real-time information about
     * transaction progress and enables clients to understand the current
     * processing stage and any required actions.
     * 
     * Status Lifecycle:
     * - PENDING: Initial status when transaction is queued for processing
     * - PROCESSING: Active validation, risk assessment, and compliance checks
     * - AWAITING_APPROVAL: Manual approval or additional authorization required
     * - SETTLEMENT_IN_PROGRESS: Settlement operations are being executed
     * - COMPLETED: Transaction successfully completed and settled
     * - FAILED: Technical failure or system error occurred
     * - REJECTED: Business rules or compliance policies prevented approval
     * - CANCELLED: Transaction cancelled before completion
     * 
     * Integration Notes:
     * - Status updates are propagated through the event streaming platform
     * - Real-time status changes trigger customer notifications
     * - Status history is maintained for audit and compliance requirements
     */
    @NotNull(message = "Transaction status cannot be null")
    @Schema(
        description = "Current transaction processing status",
        example = "COMPLETED",
        required = true
    )
    @JsonProperty("status")
    private TransactionStatus status;
    
    /**
     * External reference number for system correlation and reconciliation.
     * 
     * Provides a correlation identifier that links this transaction to external
     * systems, customer references, or batch processing operations. This field
     * is particularly important for reconciliation processes, customer service
     * inquiries, and integration with core banking systems.
     * 
     * Usage Scenarios:
     * - Core banking system transaction correlation
     * - Customer-provided reference numbers for transfers
     * - Batch processing job identifiers
     * - External payment network reference numbers
     * - Regulatory reporting correlation identifiers
     * 
     * Format Flexibility:
     * - Alphanumeric characters to support various external system formats
     * - Optional field to accommodate transactions without external references
     * - Maximum length accommodates most external system identifier formats
     */
    @Size(max = 50, message = "Reference number cannot exceed 50 characters")
    @Pattern(regexp = "^[A-Za-z0-9\\-_]*$", message = "Reference number can only contain alphanumeric characters, hyphens, and underscores")
    @Schema(
        description = "External reference number for correlation and reconciliation",
        example = "REF-2024-001234",
        required = false
    )
    @JsonProperty("referenceNumber")
    private String referenceNumber;
    
    /**
     * Provides a string representation of the TransactionResponse object.
     * 
     * This method is automatically generated by Lombok's @Data annotation but
     * is documented here for clarity. The toString method provides a formatted
     * string containing all field values, which is useful for logging, debugging,
     * and audit trail generation.
     * 
     * Security Note:
     * Sensitive information such as account numbers may be masked in production
     * logging configurations to protect customer privacy and comply with
     * data protection regulations.
     * 
     * @return String representation of the transaction response
     */
    // toString() method provided by Lombok @Data annotation
    
    /**
     * Determines if this TransactionResponse represents a successfully completed transaction.
     * 
     * Convenience method to check if the transaction has reached a successful
     * completion state. This is useful for client applications that need to
     * quickly determine transaction success without examining the detailed status.
     * 
     * @return true if the transaction status indicates successful completion, false otherwise
     */
    public boolean isSuccessful() {
        return status != null && status.isSuccessful();
    }
    
    /**
     * Determines if this TransactionResponse represents a transaction that has failed.
     * 
     * Convenience method to check if the transaction has reached a failed state
     * (FAILED, REJECTED, or CANCELLED). This enables client applications to
     * quickly identify failed transactions and implement appropriate error handling.
     * 
     * @return true if the transaction status indicates a failure outcome, false otherwise
     */
    public boolean isFailedTransaction() {
        return status != null && status.isFailedOutcome();
    }
    
    /**
     * Determines if this TransactionResponse represents a transaction requiring manual intervention.
     * 
     * Convenience method to identify transactions that are awaiting manual approval
     * or additional authorization. This helps client applications provide appropriate
     * messaging to customers about pending transactions requiring further action.
     * 
     * @return true if the transaction requires manual intervention, false otherwise
     */
    public boolean requiresManualApproval() {
        return status != null && status.requiresManualIntervention();
    }
    
    /**
     * Determines if this TransactionResponse represents an actively processing transaction.
     * 
     * Convenience method to check if the transaction is currently being processed
     * through various validation, approval, or settlement stages. This enables
     * client applications to provide real-time status updates to customers.
     * 
     * @return true if the transaction is actively being processed, false otherwise
     */
    public boolean isActivelyProcessing() {
        return status != null && status.isActivelyProcessing();
    }
    
    /**
     * Gets a human-readable display name for the current transaction status.
     * 
     * Provides a customer-friendly representation of the transaction status
     * suitable for display in user interfaces and customer notifications.
     * This method leverages the TransactionStatus enum's built-in display
     * name functionality.
     * 
     * @return Human-readable status description, or "Unknown" if status is null
     */
    public String getStatusDisplayName() {
        return status != null ? status.getDisplayName() : "Unknown";
    }
    
    /**
     * Gets a detailed description of the current transaction status.
     * 
     * Provides comprehensive information about what the current transaction
     * status means, suitable for operational monitoring, customer service,
     * and detailed audit logging purposes.
     * 
     * @return Detailed status description, or "Status information unavailable" if status is null
     */
    public String getStatusDescription() {
        return status != null ? status.getDescription() : "Status information unavailable";
    }
}