package com.ufs.risk.model;

// External imports with version information
import jakarta.persistence.Entity; // version 3.1.0
import jakarta.persistence.Id; // version 3.1.0
import jakarta.persistence.GeneratedValue; // version 3.1.0
import jakarta.persistence.GenerationType; // version 3.1.0
import jakarta.persistence.ManyToOne; // version 3.1.0
import jakarta.persistence.JoinColumn; // version 3.1.0
import jakarta.persistence.Enumerated; // version 3.1.0
import jakarta.persistence.EnumType; // version 3.1.0
import jakarta.persistence.Column; // version 3.1.0
import jakarta.persistence.Table; // version 3.1.0
import lombok.Data; // version 1.18.30
import java.time.LocalDateTime; // N/A - Java standard library

// Internal imports
import com.ufs.risk.model.RiskScore;
import com.ufs.transaction.model.Transaction;

/**
 * JPA Entity representing a fraud alert generated by the AI-powered fraud detection system.
 * 
 * This entity serves as a core component of the Fraud Detection System (F-006) and AI-Powered 
 * Risk Assessment Engine (F-002). It captures fraud alerts triggered when transactions are 
 * flagged as potentially fraudulent by the machine learning models analyzing transaction 
 * patterns, risk scores, and behavioral anomalies.
 * 
 * Business Requirements Addressed:
 * - F-006: Fraud Detection System (Technical Specifications/2.1.2 AI and Analytics Features)
 *   - Provides structured representation of fraud alerts generated by the system
 *   - Enables tracking and management of fraud investigations
 *   - Supports real-time fraud detection and monitoring capabilities
 * 
 * - F-002-RQ-001: Real-time risk scoring (Technical Specifications/2.2.2 F-002)
 *   - Integrates with risk assessment engine to capture fraud alerts based on real-time scoring
 *   - Links fraud alerts to specific risk scores that triggered the detection
 *   - Enables sub-500ms fraud detection response times through optimized data structures
 * 
 * Technical Context:
 * - Supports high-frequency fraud detection processing (5,000+ alerts per second)
 * - Integrates with AI/ML models for predictive fraud pattern recognition
 * - Provides comprehensive audit trail for regulatory compliance and investigation
 * - Enables real-time alerting and notification systems for security teams
 * 
 * Database Schema:
 * - Table: fraud_alerts
 * - Primary Key: BIGINT (auto-generated using database identity strategy)
 * - Foreign Keys: transaction_id (references transactions), risk_score_id (references risk_scores)
 * - Indexes: Recommended on transaction_id, risk_score_id, status, timestamp for query performance
 * - Constraints: Non-null constraints on critical fields, proper referential integrity
 * 
 * Security Considerations:
 * - Contains sensitive fraud detection information requiring appropriate access controls
 * - Audit logging enabled for all CRUD operations on fraud alerts
 * - Data retention policies apply per regulatory requirements (typically 7+ years)
 * - Encryption at rest recommended for sensitive alert details and reasons
 * 
 * Performance Characteristics:
 * - Optimized for high-volume insert operations from real-time fraud detection
 * - Efficient querying capabilities for fraud investigation workflows
 * - Minimal storage overhead while maintaining comprehensive audit information
 * - Supports horizontal scaling through proper indexing and query optimization
 * 
 * Integration Points:
 * - Transaction Service: Links to specific transactions that triggered fraud alerts
 * - Risk Assessment Service: Associates with risk scores that contributed to fraud detection
 * - Notification Service: Triggers real-time alerts to security and compliance teams
 * - Investigation Service: Provides data foundation for fraud case management
 * 
 * @author Unified Financial Services Platform Development Team
 * @version 1.0
 * @since 1.0
 */
@Entity
@Table(name = "fraud_alerts")
@Data
public class FraudAlert {

    /**
     * Unique identifier for the fraud alert record.
     * 
     * Auto-generated using database identity strategy for optimal performance
     * in high-volume fraud detection scenarios. The IDENTITY strategy provides
     * excellent performance for insert-heavy workloads typical in fraud detection.
     * 
     * Database Mapping:
     * - Column: id
     * - Type: BIGINT
     * - Constraints: Primary Key, Non-updatable, Non-null, Auto-increment
     * - Performance: Optimized for high-frequency inserts from fraud detection engine
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false, updatable = false)
    private Long id;

    /**
     * Reference to the transaction that triggered this fraud alert.
     * 
     * This Many-to-One relationship links the fraud alert to the specific financial
     * transaction that was flagged by the AI-powered fraud detection system. The
     * relationship enables comprehensive investigation workflows and provides
     * complete context for fraud analysis.
     * 
     * The relationship is mandatory as every fraud alert must be associated with
     * a specific transaction. The foreign key constraint ensures referential
     * integrity and prevents orphaned fraud alerts.
     * 
     * Database Mapping:
     * - Foreign Key: transaction_id
     * - References: transactions.id
     * - Fetch Strategy: LAZY (for performance optimization)
     * - Cascade: None (transaction lifecycle independent of fraud alerts)
     * - Constraints: Non-null, Foreign Key constraint
     * - Recommended Index: For efficient joins and transaction-based queries
     */
    @ManyToOne(fetch = jakarta.persistence.FetchType.LAZY)
    @JoinColumn(name = "transaction_id", nullable = false)
    private Transaction transaction;

    /**
     * Reference to the risk score that contributed to triggering this fraud alert.
     * 
     * This Many-to-One relationship associates the fraud alert with the specific
     * risk assessment that contributed to the fraud detection. While multiple
     * factors may contribute to fraud detection, this captures the primary risk
     * score that exceeded fraud thresholds.
     * 
     * The relationship enables correlation analysis between risk scoring accuracy
     * and fraud detection effectiveness, supporting continuous improvement of
     * the AI-powered risk assessment models.
     * 
     * Database Mapping:
     * - Foreign Key: risk_score_id
     * - References: risk_scores.id
     * - Fetch Strategy: LAZY (for performance optimization)
     * - Cascade: None (risk score lifecycle independent of fraud alerts)
     * - Constraints: Non-null, Foreign Key constraint
     * - Recommended Index: For risk score correlation analysis and reporting
     */
    @ManyToOne(fetch = jakarta.persistence.FetchType.LAZY)
    @JoinColumn(name = "risk_score_id", nullable = false)
    private RiskScore riskScore;

    /**
     * Detailed reason or explanation for why the fraud alert was triggered.
     * 
     * This field captures the specific criteria, patterns, or anomalies that
     * caused the AI-powered fraud detection system to flag the transaction.
     * The information is crucial for:
     * - Fraud investigation and analysis
     * - Model explainability and transparency
     * - Regulatory compliance and audit requirements
     * - Continuous improvement of fraud detection algorithms
     * 
     * Examples of fraud reasons:
     * - "Transaction amount 500% above customer's typical spending pattern"
     * - "Geolocation anomaly: Transaction from high-risk country"
     * - "Velocity pattern: 5 transactions within 2 minutes exceeds normal behavior"
     * - "Merchant category mismatch with customer's historical preferences"
     * - "AI model confidence score 0.95 for fraudulent transaction pattern"
     * 
     * Database Mapping:
     * - Column: reason
     * - Type: TEXT/VARCHAR(2000)
     * - Constraints: Non-null (required for all fraud alerts)
     * - Indexing: Consider full-text search indexing for investigation queries
     */
    @Column(name = "reason", nullable = false, length = 2000)
    private String reason;

    /**
     * Current status of the fraud alert in the investigation lifecycle.
     * 
     * This enum field tracks the fraud alert through its complete lifecycle
     * from initial detection to final resolution. The status enables workflow
     * management, performance monitoring, and regulatory reporting.
     * 
     * Status transitions follow a defined workflow:
     * - NEW: Initial status when fraud alert is first generated
     * - INVESTIGATING: Alert is being actively reviewed by security team
     * - RESOLVED_FRAUD: Investigation confirmed fraudulent activity
     * - RESOLVED_FALSE_POSITIVE: Investigation determined legitimate transaction
     * 
     * Database Mapping:
     * - Column: status
     * - Type: VARCHAR(50) (enum stored as string for flexibility)
     * - Constraints: Non-null
     * - Default Value: NEW (for newly created alerts)
     * - Recommended Index: For status-based reporting and workflow management
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private AlertStatus status = AlertStatus.NEW;

    /**
     * Timestamp when the fraud alert was first generated by the detection system.
     * 
     * This field captures the exact moment when the AI-powered fraud detection
     * system identified the suspicious transaction and created the alert. The
     * timestamp is critical for:
     * - Regulatory compliance and audit trails
     * - Performance monitoring and SLA tracking
     * - Temporal analysis of fraud patterns
     * - Investigation timeline establishment
     * - Real-time alerting and notification timing
     * 
     * The timestamp should be set immediately upon fraud detection to ensure
     * accuracy in real-time monitoring and compliance reporting.
     * 
     * Database Mapping:
     * - Column: timestamp
     * - Type: TIMESTAMP
     * - Constraints: Non-null
     * - Default Value: Current timestamp (set during entity creation)
     * - Recommended Index: For time-based queries and reporting
     */
    @Column(name = "timestamp", nullable = false)
    private LocalDateTime timestamp;

    /**
     * Default no-argument constructor required by JPA specification.
     * 
     * This constructor is used by the JPA provider (Hibernate) for entity
     * instantiation during database operations. The constructor initializes
     * the fraud alert with default values and current timestamp.
     * 
     * Application code should use the parameterized constructor or builder
     * patterns for creating new fraud alert instances.
     */
    public FraudAlert() {
        // Set default timestamp to current time when entity is created
        this.timestamp = LocalDateTime.now();
        // Set default status to NEW for newly created alerts
        this.status = AlertStatus.NEW;
    }

    /**
     * Parameterized constructor for creating fraud alert instances with required fields.
     * 
     * This constructor enables creation of fraud alerts with all mandatory information
     * populated. It automatically sets the timestamp to the current time and initializes
     * the status to NEW, representing a newly detected fraud alert.
     * 
     * @param transaction The transaction that triggered the fraud alert (required)
     * @param riskScore The risk score associated with the fraud detection (required)
     * @param reason The detailed reason for the fraud alert (required)
     */
    public FraudAlert(Transaction transaction, RiskScore riskScore, String reason) {
        this(); // Call default constructor to set timestamp and status
        this.transaction = transaction;
        this.riskScore = riskScore;
        this.reason = reason;
    }

    /**
     * Full parameterized constructor for creating fraud alert instances with all fields.
     * 
     * This constructor provides complete control over all fraud alert fields,
     * including the ability to set custom timestamps and status values. It is
     * primarily used for testing scenarios or when importing historical data.
     * 
     * @param transaction The transaction that triggered the fraud alert
     * @param riskScore The risk score associated with the fraud detection
     * @param reason The detailed reason for the fraud alert
     * @param status The current status of the fraud alert
     * @param timestamp The timestamp when the alert was generated
     */
    public FraudAlert(Transaction transaction, RiskScore riskScore, String reason, 
                     AlertStatus status, LocalDateTime timestamp) {
        this.transaction = transaction;
        this.riskScore = riskScore;
        this.reason = reason;
        this.status = status;
        this.timestamp = timestamp;
    }

    // Business logic methods for fraud alert management

    /**
     * Determines if this fraud alert is in a state that requires active investigation.
     * 
     * An alert requires investigation if it is in NEW or INVESTIGATING status,
     * indicating that the fraud case has not yet been resolved.
     * 
     * @return true if the alert requires investigation, false otherwise
     */
    public boolean requiresInvestigation() {
        return status == AlertStatus.NEW || status == AlertStatus.INVESTIGATING;
    }

    /**
     * Determines if this fraud alert has been resolved (either as fraud or false positive).
     * 
     * A resolved alert has completed the investigation process and received a
     * final determination about the legitimacy of the flagged transaction.
     * 
     * @return true if the alert has been resolved, false otherwise
     */
    public boolean isResolved() {
        return status == AlertStatus.RESOLVED_FRAUD || status == AlertStatus.RESOLVED_FALSE_POSITIVE;
    }

    /**
     * Determines if this fraud alert was confirmed as actual fraud.
     * 
     * @return true if the investigation confirmed fraudulent activity, false otherwise
     */
    public boolean isConfirmedFraud() {
        return status == AlertStatus.RESOLVED_FRAUD;
    }

    /**
     * Determines if this fraud alert was determined to be a false positive.
     * 
     * @return true if the investigation determined the transaction was legitimate, false otherwise
     */
    public boolean isFalsePositive() {
        return status == AlertStatus.RESOLVED_FALSE_POSITIVE;
    }

    /**
     * Calculates the age of the fraud alert in hours from creation to current time.
     * 
     * This method is useful for monitoring investigation SLAs and identifying
     * alerts that may require escalation due to extended processing times.
     * 
     * @return the age of the alert in hours as a long value
     */
    public long getAgeInHours() {
        return java.time.Duration.between(timestamp, LocalDateTime.now()).toHours();
    }

    /**
     * Determines if this fraud alert has exceeded standard investigation timeframes.
     * 
     * Uses configurable thresholds to identify alerts that may require escalation:
     * - NEW alerts older than 4 hours
     * - INVESTIGATING alerts older than 24 hours
     * 
     * @return true if the alert should be escalated due to age, false otherwise
     */
    public boolean shouldEscalate() {
        long ageHours = getAgeInHours();
        
        switch (status) {
            case NEW:
                return ageHours > 4; // Escalate NEW alerts after 4 hours
            case INVESTIGATING:
                return ageHours > 24; // Escalate investigating alerts after 24 hours
            default:
                return false; // Resolved alerts don't need escalation
        }
    }

    /**
     * Transitions the fraud alert to INVESTIGATING status with timestamp validation.
     * 
     * This method should be called when a fraud analyst begins investigation
     * of the alert. It includes validation to ensure proper status transitions.
     * 
     * @throws IllegalStateException if the alert is not in NEW status
     */
    public void startInvestigation() {
        if (status != AlertStatus.NEW) {
            throw new IllegalStateException("Cannot start investigation - alert status is " + status);
        }
        this.status = AlertStatus.INVESTIGATING;
    }

    /**
     * Resolves the fraud alert as confirmed fraud with validation.
     * 
     * This method should be called when investigation confirms the transaction
     * was indeed fraudulent. It includes validation to ensure the alert is
     * in an appropriate state for resolution.
     * 
     * @throws IllegalStateException if the alert is already resolved
     */
    public void resolveAsFraud() {
        if (isResolved()) {
            throw new IllegalStateException("Alert is already resolved with status " + status);
        }
        this.status = AlertStatus.RESOLVED_FRAUD;
    }

    /**
     * Resolves the fraud alert as a false positive with validation.
     * 
     * This method should be called when investigation determines the flagged
     * transaction was legitimate. It includes validation to ensure proper
     * status transitions.
     * 
     * @throws IllegalStateException if the alert is already resolved
     */
    public void resolveAsFalsePositive() {
        if (isResolved()) {
            throw new IllegalStateException("Alert is already resolved with status " + status);
        }
        this.status = AlertStatus.RESOLVED_FALSE_POSITIVE;
    }
}

/**
 * Enumeration representing the lifecycle status of a fraud alert.
 * 
 * This enum defines the possible states of a fraud alert as it progresses
 * through the investigation and resolution workflow. The status values
 * enable proper workflow management, performance monitoring, and
 * regulatory compliance reporting.
 * 
 * Status Transition Flow:
 * NEW -> INVESTIGATING -> (RESOLVED_FRAUD | RESOLVED_FALSE_POSITIVE)
 * 
 * Business Rules:
 * - All fraud alerts start in NEW status
 * - Alerts can only be resolved from INVESTIGATING status
 * - Resolved alerts cannot change status (terminal states)
 * - Status changes should be logged for audit purposes
 * 
 * @author Unified Financial Services Platform Development Team
 * @version 1.0
 * @since 1.0
 */
public enum AlertStatus {
    
    /**
     * Initial status assigned to newly created fraud alerts.
     * 
     * Characteristics:
     * - Alert has been generated by the AI fraud detection system
     * - No human investigation has begun
     * - Alert is queued for review by security team
     * - SLA clock starts ticking for investigation response
     * - System notifications may be triggered for immediate attention
     * 
     * Next Possible States: INVESTIGATING
     */
    NEW,
    
    /**
     * Status indicating the fraud alert is under active investigation.
     * 
     * Characteristics:
     * - Security analyst has started reviewing the alert
     * - Investigation activities are in progress
     * - Additional data gathering and analysis may be occurring
     * - Customer may be contacted for verification
     * - Decision pending on final resolution
     * 
     * Next Possible States: RESOLVED_FRAUD, RESOLVED_FALSE_POSITIVE
     */
    INVESTIGATING,
    
    /**
     * Terminal status indicating the investigation confirmed fraudulent activity.
     * 
     * Characteristics:
     * - Investigation has concluded with fraud confirmation
     * - Appropriate actions have been taken (account blocking, transaction reversal)
     * - Law enforcement may have been notified if required
     * - Customer has been informed of the fraud determination
     * - Case documentation has been completed for regulatory compliance
     * 
     * Next Possible States: None (terminal state)
     */
    RESOLVED_FRAUD,
    
    /**
     * Terminal status indicating the investigation determined the transaction was legitimate.
     * 
     * Characteristics:
     * - Investigation concluded the flagged transaction was not fraudulent
     * - Customer verification confirmed legitimate activity
     * - Transaction was cleared for processing if previously held
     * - False positive data used for improving fraud detection models
     * - Customer may receive notification of cleared security review
     * 
     * Next Possible States: None (terminal state)
     */
    RESOLVED_FALSE_POSITIVE;
    
    /**
     * Determines if this status represents a terminal state where no further
     * status transitions should occur.
     * 
     * @return true if this is a terminal status, false otherwise
     */
    public boolean isTerminal() {
        return this == RESOLVED_FRAUD || this == RESOLVED_FALSE_POSITIVE;
    }
    
    /**
     * Determines if this status represents an active investigation state.
     * 
     * @return true if investigation is active, false otherwise
     */
    public boolean isActiveInvestigation() {
        return this == INVESTIGATING;
    }
    
    /**
     * Determines if this status represents a newly created alert requiring attention.
     * 
     * @return true if this is a new alert, false otherwise
     */
    public boolean isNew() {
        return this == NEW;
    }
    
    /**
     * Provides a human-readable display name for the alert status.
     * 
     * @return user-friendly status description
     */
    public String getDisplayName() {
        switch (this) {
            case NEW:
                return "New Alert";
            case INVESTIGATING:
                return "Under Investigation";
            case RESOLVED_FRAUD:
                return "Confirmed Fraud";
            case RESOLVED_FALSE_POSITIVE:
                return "False Positive";
            default:
                return name();
        }
    }
    
    /**
     * Provides a detailed description of what the alert status means.
     * 
     * @return detailed status description for operational use
     */
    public String getDescription() {
        switch (this) {
            case NEW:
                return "Fraud alert has been generated and is awaiting investigation";
            case INVESTIGATING:
                return "Fraud alert is being actively investigated by security team";
            case RESOLVED_FRAUD:
                return "Investigation confirmed fraudulent activity";
            case RESOLVED_FALSE_POSITIVE:
                return "Investigation determined transaction was legitimate";
            default:
                return "Unknown alert status";
        }
    }
}